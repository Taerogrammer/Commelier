# 코믈리에(Commelier)

### 가상 자산 실전 감각을 기를 수 있는 모의 코인 투자 앱 💸📈

<br>

## 프로젝트 소개

**Commelier(코믈리에)** 는 실제 돈 없이도 가상 화폐 투자 흐름을 익힐 수 있는 iOS 기반 모의 투자 앱입니다.

실시간 코인 시세를 기반으로 매매를 연습하고, 나만의 포트폴리오를 분석하며 투자 감각을 키울 수 있도록 설계되었습니다.

사용자는 실시간 트렌드를 확인하며 실제 투자 환경과 유사한 UX를 경험할 수 있습니다.

<br><br>

# 주요 기능

| 기능명                     | 설명                                                                 |
|--------------------------|----------------------------------------------------------------------|
| 💸 모의 투자 기능         | 실제 돈 없이도 코인을 사고팔며 실전처럼 트레이딩 연습 가능                 |
| 📈 실시간 시세 반영       | WebSocket을 통한 실시간 코인 시세 반영 및 빠른 매매 체험 제공              |
| 📊 포트폴리오 관리        | 보유 자산의 수익률, 평가 금액, 비중 등을 시각화하여 한눈에 확인 가능        |
| 🔥 인기 코인 & 키워드     | 현재 트렌디한 코인과 키워드를 실시간으로 확인하여 시장 흐름 파악 가능        |
| 🌓 라이트/다크 모드 지원 | 사용자의 기호에 맞게 UI 테마를 자동 혹은 수동으로 변경 가능                 |
| ⚠️ 네트워크 상태 알림     | 연결 오류 발생 시 원인 및 해결 방향을 사용자에게 직관적으로 안내            |

<br><br>

# 개발 기간 및 팀 구성

- 개발 기간 
  - 2025.03.06 ~ 2025.03.11
  - 2025.03.25 ~ 2025.04.10
- 개발 인원: 1인 (기획, 디자인, 개발 전부 단독 수행)
- 타겟 플랫폼: iOS (iPhone)
- 배포: App Store

<br><br><br>

# 기술 스택

### 아키텍처 & 설계 패턴

- MVVM (Model-View-ViewModel) + Input/Output 구조

- Repository Pattern / Router Pattern / UseCase 분리

- Factory Method Pattern (객체 생성 분리)

- DI / DIP 적용

- Singleton

<br>


### 프레임워크 & 라이브러리

| 목적         | 사용 기술                                                                 |
|--------------|---------------------------------------------------------------------------|
| **UI**       | UIKit (전체 구성), SwiftUI (일부 View), SnapKit                          |
| **네트워크** | Alamofire, WebSocket 기반 API                                            |
| **데이터**   | Realm (정규화 구조 적용), NumberterKit (직접 개발한 숫자 포맷 라이브러리) |
| **비동기 처리** | Combine, RxSwift, RxCocoa, RxGesture, RxDataSources                     |
| **차트**     | DGCharts (포트폴리오 시각화), Charts 프레임워크                          |
| **이미지 캐싱** | Kingfisher        


<br><br><br>

# 기술 설명

### WebSocket 기반 실시간 데이터 처리

코인의 가격 정보는 WebSocket API를 통해 실시간으로 받아옵니다.

실시간 데이터를 Combine 퍼블리셔 패턴으로 설계하여 ViewModel에서 구독 → UI에 자동 반영되도록 구현하였습니다.

이 구조는 여러 종목의 동시 구독, 연결 유지 및 재시도, 메시지 파싱 로직 등을 포함하며, 실시간성이 중요한 투자 시뮬레이션 앱의 특성에 최적화되어 있습니다.

단순 폴링 방식이 아닌 Push 기반 아키텍처를 구현하여 서버 리소스를 줄이고 반응 속도를 높였습니다.

<br>

### 아키텍쳐 - MVVM InOut 패턴

MVVM(Model-View-ViewModel)은 ```UI 로직과 비즈니스 로직을 분리하여 유지보수성과 확장성을 높이는 디자인 패턴```으로, 데이터 바인딩을 통해 UI 변화를 효율적으로 관리할 수 있습니다.
특히 InOut 패턴을 적용하여 입력(Input)과 출력(Output)을 명확하게 정의하고, RxSwift와 Combine을 활용하여 비동기 데이터 흐름을 관리함으로써 코드의 가독성과 유지 보수성을 높였습니다.

<br>

### 숫자 데이터 처리를 위한 자체 유틸리티 - NumberterKit
코인의 시세, 수익률, 평가 금액 등은 다양한 수치 포맷이 요구됩니다.

기존 DecimalFormatter만으로는 표현이 어려운 상황(Int64 ↔ Decimal ↔ String 변환, 소수점 자리수 제한 등)을 해결하기 위해, 직접 경량 유틸리티 라이브러리 NumberterKit을 개발하였습니다.

해당 유틸은 Swift Package Manager로 모듈화하여 다른 프로젝트에서도 재사용이 가능하고, 테스트 용이성 및 유지보수성까지 고려하였습니다.

<br>

### 객체 생성의 책임 분리 - Factory Method Pattern
앱의 주요 구성 요소(ViewModel, UseCase, Repository 등)는 Factory Method Pattern을 통해 생성 책임을 외부로 분리하여 관리합니다.

이 구조는 각 클래스의 역할을 명확하게 하며, **의존성 주입(DI)** 이 가능하게 되어 테스트 코드 작성이 쉬워지고, 확장성과 유지보수성이 크게 향상됩니다.

SRP(단일 책임 원칙), OCP(개방-폐쇄 원칙), DIP(의존성 역전 원칙)를 만족하는 구조로 설계되었습니다.

<br>

### 데이터 정규화 - Realm
Realm을 사용해 모의 투자 내역, 자산 정보, 코인 메타 정보를 저장합니다.

데이터 구조 설계 시 정규화를 적용하여 코인 정보가 중복 저장되지 않도록 구성했습니다.

예: 거래 기록은 코인 정보를 직접 들고 있지 않고, 참조하여 가져오는 방식
→ 데이터 변경 시 일괄 반영 가능하고, Anomaly 방지 및 데이터 무결성 유지 효과

<br>

### 고정 소수점 계산을 위한 `Decimal` 사용

코믈리에는 **가상 자산의 시세, 수익률, 평가 금액 등 다양한 수치 데이터를 정확하게 처리**하기 위해 `Swift.Decimal` 타입을 적극 활용하였습니다.  
이는 금융 데이터 처리에 있어서 **정밀도와 안정성**을 보장하기 위해 필수적인 선택이었습니다.

| 항목              | `Double`                     | `Decimal`                          | `Int64`                          |
|-------------------|------------------------------|------------------------------------|----------------------------------|
| **정밀도**         | 소수점 오차 발생            | 고정 소수점, 금융 계산에 적합     | 정수 전용 (소수 불가)            |
| **성능**           | 빠름                        | 다소 느림 (정확성 중심)           | 빠름                            |
| **저장 크기**       | 64비트                        | 128비트 (`Decimal128`)              | 64비트                            |
| **Realm 지원**     | 지원                         | `RLMDecimal128`으로 저장 가능     | 지원                             |
| **소수점 계산**     | 불안정                      | 매우 안정적                       | 불가능 (별도 로직 필요)           |

#### 왜 `Decimal`이 필요한가?

- `Double`은 부동소수점 방식으로 인해 정밀한 소수 계산 시 오차가 발생할 수 있습니다.
- 이는 투자 수익률, 총 평가 금액 등의 계산 결과가 **사용자에게 잘못 전달될 수 있는 리스크**를 유발합니다.
- `Decimal`은 **고정 소수점 정밀 연산**을 지원하여, **금융/투자와 같이 정밀한 계산이 요구되는 상황에 최적화**되어 있습니다.
- Realm도 `RLMDecimal128` 타입으로 매핑되어 `Decimal` 데이터를 안전하게 저장하고 불러올 수 있습니다.

<br>

> 정확한 수익률 계산과 자산 평가를 위해, 코믈리에는 `Decimal`을 적극적으로 도입하여 **투자 시뮬레이션 앱으로서의 신뢰성을 강화**하였습니다.

<br>

## WebSocket 구조 설계

여러 ViewModel에서 WebSocket 데이터를 공유할 때 **결합도 문제**를 해결하기 위해, 
의존성 역전 원칙(DIP)과 의존성 주입(DI)을 기반으로 설계를 적용했습니다.

이를 통해 다수의 ViewModel에서 **결합도는 낮추고**, **테스트 가능성과 확장성은 높이는 구조**를 구현했습니다.

<br>

### 배경 및 문제 정의

기존 구조에서는 `WebSocketManager.shared`를 각 ViewModel에서 직접 참조하며 다음과 같은 문제가 발생했습니다:

- **강한 결합도**로 인해 테스트 및 유지보수가 어려움
- **중복 연결** 및 **불필요한 메시지 재구독** 발생 가능성
- WebSocketManager에 대한 **직접 의존성** → 변경에 취약

<br>

### 해결 전략

WebSocketManager.shared와 같은 싱글톤 구현에 직접 의존하는 구조는 코드 간 결합도를 높이고 테스트를 어렵게 만듭니다. 이를 해결하기 위해 본 프로젝트에서는 **DIP (의존성 역전 원칙)** 와 **DI (의존성 주입)** 를 적용했습니다.

| 개념 | 설명 |
|------|------|
| **DIP** | ViewModel이 구체 구현이 아닌 **WebSocketProvider 프로토콜**에 의존 |
| **DI** | WebSocketProvider는 외부에서 **주입**됨 (생성자 or 팩토리) |

---

<br>

### 기대 효과

- 테스트 가능성 향상: Mock 객체 주입으로 유닛 테스트 가능  
- 유지보수성 향상: 구현 변경이 ViewModel에 영향 없음  
- 확장성 확보: 다른 WebSocket 서버로의 이식이나 멀티 서버 대응 용이

> 이 구조는 MVVM 기반 iOS 프로젝트에서 **실시간 데이터 처리 구조**를 깔끔하게 분리하고,
> 다양한 모듈 간 재사용성과 테스트 가능성을 높이기 위한 기반이 됩니다.
